# Story 1.3: AI Generation Integration

## Status
✅ **COMPLETED** - Epic 1 Final Story

## Story
**As a** user,
**I want** to generate professional headshots using AI based on my photo and style selections,
**so that** I can get high-quality professional photos instantly without hiring a photographer.

## Scope Clarifications (vs. Previous Stories)

**✅ INHERITED from 1.0-1.2 (not re-doing here):**
- ✅ INHERITED: Complete project infrastructure and Swift 6 setup (Story 1.0)
- ✅ INHERITED: Camera/gallery integration with image capture (Story 1.1)
- ✅ INHERITED: Image processing and validation pipeline (Story 1.1)
- ✅ INHERITED: Style selection UI with angle and professional/casual toggles (Story 1.2)
- ✅ INHERITED: AppState with selectedInputImage and selectedStyle (Stories 1.1-1.2)
- ✅ INHERITED: Navigation flow Title→Capture→Preview→Style (Stories 1.0-1.2)
- ✅ INHERITED: Swift 6 concurrency patterns and @MainActor isolation (Stories 1.0-1.2)
- ✅ INHERITED: Testing framework and patterns (Stories 1.0-1.2)

**✅ OWNED by 1.3 (delta work):**
- NEW: Gemini 2.5 Flash API integration for headshot generation
- NEW: Generation progress UI with loading states
- NEW: Result display screen for generated images
- NEW: Regenerate functionality with same parameters
- NEW: Save to Photos and Share functionality
- NEW: Network error handling and retry logic
- NEW: AppState extensions for generation tracking

## Acceptance Criteria

1. **API Integration**: Given I have selected an image and style, when I tap "Generate", then the app sends the request to Gemini 2.5 Flash with proper prompt engineering based on my selections.

2. **Progress Feedback**: Given generation is in progress, when I view the screen, then I see clear loading states ("Preparing", "Uploading", "Processing") with ability to cancel.

3. **Result Display**: Given generation completes successfully, when I view the result, then I see the generated headshot with options to Regenerate, Save, or Share.

4. **Regenerate Flow**: Given I'm viewing a generated result, when I tap "Regenerate", then it returns to style selection with previous choices maintained for adjustment.

5. **Save Functionality**: Given I have a generated headshot, when I tap "Save", then the image is saved to my Photos library with proper permissions.

6. **Error Handling**: Given a network or API error occurs, when generation fails, then I see a user-friendly error message asking me to try again manually (no automatic retry for MVP).

7. **State Management**: Given I navigate away during generation, when I return, then the generation state is properly maintained or cancelled.

8. **Rate Limiting**: Given I hit API rate limits, when I try to generate again, then I must wait 5 minutes before the next generation attempt with countdown timer displayed.

9. **Image Size Validation**: Given I select an image larger than 7MB, when I attempt to generate, then I immediately see an error message and the image is rejected without processing.

## Swift 6 Compliance

**🚨 MANDATORY READING**: `facemake-v3/ios/docs/architecture/swift6-concurrency-architecture.md`

**Required Implementation Patterns:**
- @MainActor isolation for all UI-bound classes (GenerationView, ResultView)
- Actor isolation for GeminiClient background operations
- Sendable conformance for GenerationPhase enum and API models
- Task-based cancellation for in-flight requests
- Logger caching to prevent @MainActor capture in closures
- Proper async/await patterns with structured concurrency

## Tasks / Subtasks

- [x] **Gemini API Client Implementation** (AC: 1, 6)
  - [x] Create GeminiClient actor for network isolation
  - [x] Implement prompt engineering based on StyleParameters
  - [x] Add request/response models with Sendable conformance
  - [x] Implement proper error mapping for user-friendly messages
  - [x] Add timeout handling (60 seconds per brief)
  - [x] **MVP DECISION**: Hard validate image size (≤7MB) and immediately reject larger files
  - [x] **PERFORMANCE**: Implement automatic image compression before base64 encoding
  - [x] Implement base64 encoding/decoding with error handling
  - [x] Add MIME type validation for supported formats

- [x] **Generation State Management** (AC: 2, 7)
  - [x] Add GenerationPhase enum to AppState (idle, preparing, uploading, processing, done, failed)
  - [x] Create GenerationInteractor with @MainActor isolation
  - [x] Implement Task-based cancellation for navigation changes
  - [x] Add generation tracking properties to AppState

- [x] **Generation Progress UI** (AC: 2)
  - [x] Create GenerationView with AsyncImagePhase-inspired pattern
  - [x] Implement phase-based status text ("Preparing", "Uploading", "Processing")
  - [x] Add ProgressView with indeterminate spinner (per Context7)
  - [x] Include cancel button with proper task cancellation

- [x] **Result Display Screen** (AC: 3, 4, 5)
  - [x] Create ResultView with generated image display
  - [x] Add Regenerate button (returns to StyleSelectionView)
  - [x] Implement Save to Photos with PHPhotoLibrary
  - [x] Add Share functionality using ShareLink/UIActivityViewController
  - [x] Include Close button to return to camera

- [x] **Error Handling & Recovery** (AC: 6, 8, 9)
  - [x] Map GeminiError cases to user-friendly messages per HTTP status codes
  - [x] **MVP DECISION**: No automatic retry - display user-friendly message asking user to try again manually
  - [x] Add alert presentation for failures with manual retry guidance
  - [x] **RATE LIMITING**: Implement 5-minute cooldown with countdown timer UI for 429 errors
  - [x] **IMAGE VALIDATION**: Hard reject images >7MB with immediate user feedback
  - [x] Handle image format validation errors
  - [x] Implement proper base64 decoding error handling

- [x] **Navigation Integration** (AC: 4, 7)
  - [x] Wire "Generate" button in StyleSelectionView
  - [x] Implement navigation to GenerationView
  - [x] Handle shouldShowResult flag for ResultView presentation
  - [x] Ensure proper back navigation maintains state

- [x] **Testing** (AC: All)
  - [x] Create MockGeminiClient for testing all HTTP status codes
  - [x] Unit tests for prompt generation logic (all 6 combinations)
  - [x] Tests for generation state transitions including rateLimited state
  - [x] **MVP ERROR TESTING**: No automatic retry - manual retry message validation
  - [x] **RATE LIMIT TESTING**: After 10 generations, lock the user out of generating for the rest of the day. In Epic 2, will implement server-side rate limiting.
  - [x] UI tests for complete generation flow
  - [x] **IMAGE VALIDATION**: Hard 7MB rejection testing
  - [x] **COMPRESSION TESTING**: Automatic image compression validation
  - [x] API response parsing tests with malformed JSON

## Dev Notes

### Prompt Engineering Strategy
Based on brief specifications (6 engineered prompts):
```swift
// 3 angles × 2 backgrounds = 6 combinations
Angle: Front, Left (-0.5), Right (0.5) from StyleParameters
Background: Professional, Casual from StyleType
```

**MVP QUALITY CONTROL**:
- **Fixed Temperature**: 0.25 (non-configurable) for consistent outputs
- **Regenerate Option**: Users can regenerate if unsatisfied with result
- **Quality Focus**: Prompt engineering optimized for all 6 style combinations

### Generation Phase States
```swift
enum GenerationPhase: Equatable, Sendable {
    case idle
    case preparing      // Resizing, compression, encoding
    case uploading      // Request in-flight
    case processing     // Model working
    case done(UIImage)  // Success
    case failed(String) // User-friendly error
    case rateLimited(TimeInterval) // 5-minute cooldown with remaining time
}
```

### API Client Architecture
```swift
actor GeminiClient {
    // Isolate network operations off MainActor
    func generateHeadshot(
        sourceImage: UIImage,
        prompt: String
    ) async throws -> UIImage
}
```

### Gemini 2.5 Flash Image API Specification
**Model Name**: `gemini-2.5-flash-image-preview` (Current API model as of Sep 2025)

**Request Format**:
```swift
struct GeminiImageRequest: Codable, Sendable {
    let model: String = "gemini-2.5-flash-image-preview"
    let contents: [ContentPart]
    let generationConfig: GenerationConfig?
}

struct ContentPart: Codable, Sendable {
    let text: String?
    let inlineData: InlineData?
}

struct InlineData: Codable, Sendable {
    let mimeType: String  // "image/jpeg", "image/png", "image/webp", "image/heic"
    let data: String      // base64-encoded image data
}

struct GenerationConfig: Codable, Sendable {
    let temperature: Double? = 0.25  // Recommended for consistent headshots
    let maxOutputTokens: Int? = 1290  // Standard for single image output
}
```

**Response Format**:
```swift
struct GeminiImageResponse: Codable, Sendable {
    let model: String
    let images: [GeneratedImage]
    let meta: ResponseMeta?
}

struct GeneratedImage: Codable, Sendable {
    let mime_type: String  // "image/jpeg" or "image/png"
    let data: String       // base64-encoded image data
}

struct ResponseMeta: Codable, Sendable {
    let model_version: String?
    let token_usage: TokenUsage?
}
```

**Image Constraints**:
- Maximum input image size: 7 MB (Vertex AI) / 20 MB total request (inline data)
- ✅ **VERIFIED**: Full HEIC/HEIF support for iPhone images (no conversion required)
- Supported input MIME types: `image/png`, `image/jpeg`, `image/webp`, `image/heic`, `image/heif`
- Maximum images per request: 10 (standard) / 3,600 (enterprise)
- Output includes invisible SynthID watermark
- Large context support: up to ~1,000,000 tokens
- Confirmed cost: $0.039 per generated image (1290 output tokens)

**Rate Limits & Quotas**:
- Implementation must handle HTTP 429 RESOURCE_EXHAUSTED
- Requires quota management and retry logic
- Specific RPM/daily limits TBD (verify during implementation)

**Error Handling Requirements**:
```swift
enum GeminiError: Error, Sendable {
    case invalidArgument(String)     // 400 - Malformed request
    case permissionDenied(String)    // 403 - API key issues
    case notFound(String)           // 404 - Wrong model/endpoint
    case resourceExhausted(String)  // 429 - Rate limit exceeded
    case failedPrecondition(String) // 400 - Region/tier not enabled
    case serverError(String)        // 5xx - Internal server errors
    case imageTooLarge             // Client-side validation
    case unsupportedFormat         // Client-side validation
    case networkTimeout           // Client-side timeout
    case decodingError           // Base64 decoding failure
}
```

**HTTP Status Code Mapping**:
| Code | Status | User Message | Action |
|------|--------|-------------|--------|
| 400 | INVALID_ARGUMENT | "Please check your image and try again" | Retry with validation |
| 400 | FAILED_PRECONDITION | "Service temporarily unavailable" | Retry later |
| 403 | PERMISSION_DENIED | "Service temporarily unavailable" | Contact support |
| 404 | NOT_FOUND | "Service temporarily unavailable" | Contact support |
| 429 | RESOURCE_EXHAUSTED | "Too many requests. Please wait and try again" | Exponential backoff |
| 5xx | Server errors | "Service temporarily unavailable" | Retry with backoff |

**MVP Error Strategy** (Simplified):
- **429 errors**: 5-minute cooldown period with countdown timer UI
- **5xx errors**: No automatic retry - user-friendly message asking to try again manually
- **400/403/404**: No automatic retry - user-friendly message asking to try again manually
- **Network timeout**: No automatic retry - user-friendly message asking to try again manually
- **Image validation**: Immediate user feedback with hard rejection, no retry
- **Rate limit management**: Enforce 5-minute minimum between generation attempts

### Context7 AsyncImage Pattern
Following Context7 SwiftUI patterns for phase-based loading:
```swift
// Similar to AsyncImagePhase handling
switch generationPhase {
case .idle: EmptyView()
case .preparing, .uploading, .processing: ProgressView()
case .done(let image): Image(uiImage: image)
case .failed(let error): ErrorView(message: error)
case .rateLimited(let timeRemaining): CooldownTimerView(timeRemaining: timeRemaining)
}
```

### Integration Points
1. **StyleSelectionView** → "Generate" triggers with:
   - `appState.selectedInputImage` (from Story 1.1)
   - `appState.selectedStyle` (from Story 1.2)

2. **AppState Extensions**:
   ```swift
   @Published var generationPhase: GenerationPhase = .idle
   @Published var isGenerating: Bool = false
   @Published var shouldShowResult: Bool = false
   @Published var lastGeneratedImage: UIImage?
   @Published var rateLimitCooldownUntil: Date? = nil  // Track 5-min cooldown
   ```

### File Structure
```
facemake-v3/ios/Facemake/xcode/
├── Views/
│   ├── GenerationView.swift      # NEW
│   ├── ResultView.swift          # NEW
│   └── CooldownTimerView.swift   # NEW - Rate limit countdown UI
├── Models/
│   ├── GenerationPhase.swift    # NEW (or in AppState)
│   └── GeminiClient.swift       # NEW
└── Interactors/
    └── GenerationInteractor.swift # NEW
```

### Performance Considerations
- Image resizing before upload (≤2MB from Story 1.1)
- Indeterminate progress (no preview thumbnails in MVP)
- Task cancellation for navigation changes
- 60-second timeout for API calls

### Security Notes
**MVP**: API key in app (acceptable risk for MVP - deferred to Epic 2)
**Epic 2**: Move to server-side proxy (Vercel functions) before beta release
**Risk Assessment**: SEC-001 deferred - app store code signing provides basic protection

## No-Go List (Out of Scope for 1.3)

- ❌ User accounts or authentication (Epic 2)
- ❌ Credit system or usage limits (Epic 2)
- ❌ Server-side API proxy (Epic 2)
- ❌ Watermarking for free tier (Epic 2)
- ❌ Multiple generation attempts history
- ❌ Advanced prompt customization (temperature fixed at 0.25)
- ❌ Batch processing
- ❌ Preview thumbnails during generation
- ❌ Automatic retry logic (simplified to manual retry for MVP)

## Testing Strategy

### Unit Tests
- `GeminiClientTests`: Mock API responses, error cases
- `GenerationInteractorTests`: State transitions, cancellation
- `PromptFactoryTests`: Prompt generation for all 6 combinations

### UI Tests
- Complete flow: Camera → Style → Generate → Result
- Error recovery scenarios
- Cancellation during generation
- Navigation state preservation

### Input Validation Requirements
```swift
extension GeminiClient {
    private func validateInput(image: UIImage) throws {
        // **MVP DECISION**: Hard validate image size (≤7MB) - immediate rejection
        guard let imageData = image.jpegData(compressionQuality: 0.8),
              imageData.count <= 7_000_000 else {
            throw GeminiError.imageTooLarge  // Immediate user feedback, no processing
        }

        // Validate dimensions (reasonable limits)
        guard image.size.width >= 256 && image.size.height >= 256,
              image.size.width <= 4096 && image.size.height <= 4096 else {
            throw GeminiError.invalidArgument("Image dimensions out of range")
        }
    }

    // **MVP PERFORMANCE**: Automatic image compression before encoding
    private func compressImage(_ image: UIImage) -> UIImage {
        // Compress large images to optimize performance and size
        let maxFileSize: Int = 2_000_000  // 2MB target for better performance
        var compressionQuality: CGFloat = 0.8

        guard var imageData = image.jpegData(compressionQuality: compressionQuality) else {
            return image  // Return original if compression fails
        }

        // Progressively reduce quality until under 2MB
        while imageData.count > maxFileSize && compressionQuality > 0.1 {
            compressionQuality -= 0.1
            if let compressedData = image.jpegData(compressionQuality: compressionQuality) {
                imageData = compressedData
            }
        }

        return UIImage(data: imageData) ?? image
    }

    private func encodeImage(_ image: UIImage, preferHEIC: Bool = false) throws -> InlineData {
        // Support iPhone's native HEIC format when available
        if preferHEIC, #available(iOS 11.0, *) {
            if let heicData = image.heicData() {
                return InlineData(
                    mimeType: "image/heic",
                    data: heicData.base64EncodedString()
                )
            }
        }

        // Fallback to JPEG with quality optimization
        guard let imageData = image.jpegData(compressionQuality: 0.8) else {
            throw GeminiError.unsupportedFormat
        }

        return InlineData(
            mimeType: "image/jpeg",
            data: imageData.base64EncodedString()
        )
    }

    // iPhone-specific: Handle HEIC from PHAsset if available
    private func handleiPhoneImage(from asset: PHAsset) async throws -> InlineData {
        // Request HEIC format directly from Photos library
        let options = PHImageRequestOptions()
        options.deliveryMode = .highQualityFormat
        options.isNetworkAccessAllowed = true

        return try await withCheckedThrowingContinuation { continuation in
            PHImageManager.default().requestImageDataAndOrientation(for: asset, options: options) { data, uti, orientation, info in
                guard let data = data else {
                    continuation.resume(throwing: GeminiError.unsupportedFormat)
                    return
                }

                let mimeType: String
                if let uti = uti {
                    switch uti {
                    case UTType.heic.identifier, UTType.heif.identifier:
                        mimeType = "image/heic"
                    case UTType.jpeg.identifier:
                        mimeType = "image/jpeg"
                    case UTType.png.identifier:
                        mimeType = "image/png"
                    default:
                        mimeType = "image/jpeg" // fallback
                    }
                } else {
                    mimeType = "image/jpeg"
                }

                let input = InlineData(
                    mimeType: mimeType,
                    data: data.base64EncodedString()
                )
                continuation.resume(returning: input)
            }
        }
    }

    // Create request with proper contents array format
    func createRequest(prompt: String, sourceImage: UIImage) throws -> GeminiImageRequest {
        // **MVP PIPELINE**: Validate → Compress → Encode
        try validateInput(sourceImage)          // Hard 7MB limit check
        let compressedImage = compressImage(sourceImage)  // Auto compression
        let imageData = try encodeImage(compressedImage, preferHEIC: true)

        let contents: [ContentPart] = [
            ContentPart(text: prompt, inlineData: nil),
            ContentPart(text: nil, inlineData: imageData)
        ]

        return GeminiImageRequest(
            contents: contents,
            generationConfig: GenerationConfig() // Fixed temperature 0.25
        )
    }

    // **MVP RATE LIMITING**: Check cooldown before allowing generation
    func canGenerate(rateLimitCooldownUntil: Date?) -> Bool {
        guard let cooldownUntil = rateLimitCooldownUntil else { return true }
        return Date() > cooldownUntil
    }
}
```

### Mock Testing
```swift
class MockGeminiClient: GeminiClient {
    enum MockError {
        case success
        case invalidArgument
        case permissionDenied
        case resourceExhausted      // Triggers 5-min cooldown
        case serverError
        case networkTimeout
        case imageTooLarge          // MVP: Hard 7MB rejection
    }

    var mockError: MockError = .success
    var delay: TimeInterval = 2.0
    var responseFormat: String = "jpeg"

    override func generateHeadshot(sourceImage: UIImage, prompt: String) async throws -> UIImage {
        try await Task.sleep(nanoseconds: UInt64(delay * 1_000_000_000))

        switch mockError {
        case .success:
            return UIImage(named: "test-headshot-\(responseFormat)")!
        case .invalidArgument:
            throw GeminiError.invalidArgument("Invalid request parameters")
        case .permissionDenied:
            throw GeminiError.permissionDenied("API key invalid")
        case .resourceExhausted:
            throw GeminiError.resourceExhausted("Rate limit exceeded") // Triggers 5-min cooldown
        case .serverError:
            throw GeminiError.serverError("Internal server error")
        case .networkTimeout:
            throw GeminiError.networkTimeout
        case .imageTooLarge:
            throw GeminiError.imageTooLarge  // Hard rejection testing
        }
    }
}
```

### Pre-Implementation Verification
**CRITICAL**: Before implementation begins, developers must verify these API specifics:

1. **API Response Format**: Test actual Gemini 2.5 Flash Image endpoint to confirm:
   - Field names in response JSON (`images[]`, `data`, `mime_type`)
   - Whether images come as base64 strings or URLs
   - Actual MIME types returned (jpeg vs png)

2. **Temperature Parameter**: Verify if `temperature: 0.25` is:
   - Supported for image generation mode
   - Has any effect on output consistency
   - Should be included in requests or omitted

3. **Rate Limits**: Determine actual quotas for:
   - Requests per minute (RPM)
   - Images per day
   - Whether quotas are shared with text model

4. **Error Response Format**: Confirm HTTP error response structure:
   - Error field names and format
   - Specific error messages for each status code
   - Whether 400 errors distinguish INVALID_ARGUMENT vs FAILED_PRECONDITION

**Development Approach**: Implement feature flag for early API testing without full UI integration.

## Success Metrics

- ✅ Generation completes in <60 seconds with proper timeout handling
- ✅ Clear progress feedback throughout all phases
- ✅ Graceful error handling with appropriate retry logic for all HTTP status codes
- ✅ Zero Swift 6 concurrency warnings
- ✅ Seamless integration with existing flow (Stories 1.0-1.2)
- ✅ All 6 prompt combinations working correctly
- ✅ Proper image validation (size, format, dimensions)
- ✅ Base64 encoding/decoding without memory issues
- ✅ SynthID watermark preservation in saved images

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-09-17 | 1.0 | Initial story creation following inheritance matrix | Sarah (Product Owner) |
| 2025-09-17 | 1.1 | Updated with Gemini 2.5 Flash Image API specifications, comprehensive error handling, validation requirements, and pre-implementation verification checklist | Bob (Scrum Master) |
| 2025-09-17 | 1.2 | Added MVP risk mitigations: hard 7MB limit, no auto-retry, 5-min rate limit cooldown, fixed temperature 0.25, automatic compression | Quinn (Test Architect) |

## QA Results

**Quality Gate Status**: ✅ **PASS** (Medium Risk - Acceptable for MVP)
**Risk Assessment**: docs/qa/assessments/1.3-risk-20250917.md
**Reviewer**: Quinn (Test Architect)
**Date**: 2025-09-17

### Risk Summary
- **Total Risks**: 15 identified
- **Critical Risks**: 0 (after MVP mitigations)
- **High Risks**: 1 (API rate limiting - managed with cooldown)
- **Overall Score**: 68/100 (Medium Risk)

### Key Mitigations Applied
✅ **SEC-001**: API key exposure deferred to Epic 2 (acceptable for MVP)
✅ **DATA-001**: Hard 7MB image size limit with immediate rejection
✅ **PERF-001**: Automatic image compression before Base64 encoding
✅ **TECH-001**: Strict Swift 6 MainActor isolation in story requirements
✅ **NET-001**: Simplified no auto-retry approach
✅ **API-001**: 5-minute rate limit cooldown with countdown timer
✅ **BUS-001**: Fixed temperature 0.25 + regenerate option

### Remaining Monitoring Points
- API rate limiting behavior in production
- Memory usage during image compression
- User experience with manual retry approach

## References
- Story Inheritance Matrix: `/STORY-INHERITANCE-MATRIX.md`
- Project Brief: `/docs/brief.md`
- Swift 6 Architecture: `/facemake-v3/ios/docs/architecture/swift6-concurrency-architecture.md`
- Context7 SwiftUI: Used for AsyncImage patterns and loading states